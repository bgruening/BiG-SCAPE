"""Contains code to calculate the DSS for a pair of BGCs. Also contains a helper
function to perform calculation for all BGCs in a bin using just-in-time execution of
HHMAlign

These are legacy implementations of the DSS calculation, which contains a few quirks
"""

# from python
from collections import defaultdict
from typing import Optional

# from dependencies
from numpy import ndarray
from scipy.optimize import linear_sum_assignment

# from other modules
from big_scape.cli.constants import LEGACY_ANCHOR_DOMAINS
from big_scape.comparison import RecordPair

# from this module


# TODO: module lacks tests


def get_distance_from_unshared(
    bgc_pair: RecordPair, anchor_domains: set[str]
) -> tuple[float, float]:  # pragma no cover
    """Get the distance for anchor and non-anchor domains for a pair of BGCs based upon
    the unshared domains. Each domain that is unshared adds 1.0 to either distance

    Args:
        bgc_pair (BGCPair): BGCPair object to calculate this distance metric for
        anchor_domains (set[str]): A set of strings corresponding to anchor domains.
        Unshared domains that match this strings add 1.0 to distance_anchor

    Returns:
        tuple[float, float]: Two scores for the distance of non-anchor domains and of
        anchor domains, respectively
    """
    # these are the cumulative distances for non-anchor and anchor domains
    distance_non_anchor = 0.0
    distance_anchor = 0.0

    # there might be a bug in the 1.0 implementation which does some strange things.
    # attempt to assemble dictionaries that contain the numbers 1.0 chooses
    a_domains_bot: defaultdict[str, int] = defaultdict(int)
    a_domains_top: defaultdict[str, int] = defaultdict(int)
    b_domains_bot: defaultdict[str, int] = defaultdict(int)
    b_domains_top: defaultdict[str, int] = defaultdict(int)

    for hsp in bgc_pair.region_a.get_hsps():
        a_domains_bot.setdefault(hsp.domain, 0)
        a_domains_top.setdefault(hsp.domain, 0)
        a_domains_top[hsp.domain] += 1

    for hsp in bgc_pair.region_b.get_hsps():
        b_domains_bot.setdefault(hsp.domain, 0)
        b_domains_top.setdefault(hsp.domain, 0)
        b_domains_top[hsp.domain] += 1

    # increase bot slices with the counts of domains found in before the comparable region
    a_cds_list = bgc_pair.region_a.get_cds_with_domains()
    region_a_start = bgc_pair.comparable_region.a_start
    region_a_stop = bgc_pair.comparable_region.a_stop
    for cds in a_cds_list[:region_a_start]:
        for hsp in cds.hsps:
            a_domains_bot[hsp.domain] += 1

    # we have to flip the orientation here
    b_cds_list = bgc_pair.region_b.get_cds_with_domains()
    num_cds = len(b_cds_list)
    region_b_start = num_cds - bgc_pair.comparable_region.b_stop
    region_b_stop = num_cds - bgc_pair.comparable_region.b_start
    for cds in b_cds_list[:region_b_start]:
        for hsp in cds.hsps:
            b_domains_bot[hsp.domain] += 1

    # get the sets
    a_domain_set, b_domain_set = bgc_pair.comparable_region.get_domain_sets()

    # now for each domain in the full set, move the bottom to the top?
    for hsp in a_domain_set:
        a_domains_top[hsp.domain] = a_domains_bot[hsp.domain]

    for hsp in b_domain_set:
        b_domains_top[hsp.domain] = b_domains_bot[hsp.domain]

    # increase top with whatever hsps are in the sets
    for cds in a_cds_list[region_a_start:region_a_stop]:
        for hsp in cds.hsps:
            a_domains_top[hsp.domain] += 1

    for cds in b_cds_list[region_b_start:region_b_stop]:
        for hsp in cds.hsps:
            b_domains_top[hsp.domain] += 1

    # first lets get the distance generated by domains that are not shared between BGCs
    unshared_hsps = a_domain_set.symmetric_difference(b_domain_set)

    # any such unshared domain is counted as a full miss (1.0 distance)
    for unshared_hsp in unshared_hsps:
        # maybe another bug: because of the implementation in 1.0, if there is 1
        # occurence of a domain in B, but none in A, it will take 0 as unshared instead
        # of 1! This will sometimes happen because 1.0 uses a defaultdict, which just
        # sets the key to 0 if it is not found. the except clause below (taken from 1.0)
        # is never fired
        domain = unshared_hsp.domain
        try:
            num_unshared = a_domains_top[domain] - a_domains_bot[domain]
        except KeyError:
            num_unshared = b_domains_top[domain] - b_domains_bot[domain]

        if domain[:7] in anchor_domains:
            distance_anchor += num_unshared
            continue

        distance_non_anchor += num_unshared

    return distance_anchor, distance_non_anchor


def get_aligned_string_dist(string_a: str, string_b: str) -> float:  # pragma no cover
    """Calculate a simple distance between two strings of equal length from an MSA

    Strings must be equal lengths.

    Args:
        string_a (str): String to calculate distance for
        string_b (str): String to calculate distance for

    Raises:
        ValueError: Raised when string lengths do not match

    Returns:
        float: Simple distance of the two passed strings
    """
    if len(string_a) != len(string_b):
        raise ValueError(
            "String A and String B length difference in get_aligned_string_dist"
        )

    gaps = 0
    matches = 0

    for char_idx in range(len(string_a)):
        if string_a[char_idx] == string_b[char_idx]:
            if string_a[char_idx] == "-":
                gaps += 1
            else:
                matches += 1

    similarity = matches / (len(string_a) - gaps)

    return 1 - similarity


def get_sum_seq_dist(
    a_domain_list, b_domain_list, a_domain_dict, b_domain_dict, shared_domain
) -> tuple[float, int]:  # pragma no cover
    """Get the sum of squared distances and the normalization element for the DSS calculation of a
    given domain. These are the d and S parameters in supplementary note 1 in the original BiG-SCAPE
    paper

    Args:
        a_domain_list (list[HSP]): full list of domains in region A
        b_domain_list (list[HSP]): full list of domains in region B
        a_domain_dict (dict[HSP, int]): a map of domain to index in a_domain_list
        b_domain_dict (dict[HSP, int]): a map of domain to index in b_domain_list
        shared_domain (_type_): the domain to calculate the d and S parameters for

    Returns:
        tuple[float, int]: sum squared distance (d) and normalization component (S)
    """
    a_domain_count = len(a_domain_dict[shared_domain])
    b_domain_count = len(b_domain_dict[shared_domain])

    distance_matrix: ndarray = ndarray((a_domain_count, b_domain_count))

    for a_idx, a_list_idx in enumerate(a_domain_dict[shared_domain]):
        for b_idx, b_list_idx in enumerate(b_domain_dict[shared_domain]):
            string_a = a_domain_list[a_list_idx].alignment.align_string
            string_b = b_domain_list[b_list_idx].alignment.align_string

            alignment_dist = get_aligned_string_dist(string_a, string_b)

            distance_matrix[a_idx][b_idx] = alignment_dist

    best_indexes = linear_sum_assignment(distance_matrix)
    accumulated_distance: float = distance_matrix[best_indexes].sum()

    domain_count_diff = abs(a_domain_count - b_domain_count)

    sum_seq_dist = domain_count_diff + accumulated_distance
    normalization_element = max(a_domain_count, b_domain_count)

    return sum_seq_dist, normalization_element


def get_distance_from_shared(
    bgc_pair: RecordPair, anchor_domains: set[str]
) -> tuple[float, float, int, int]:  # pragma no cover
    """Get the DSS for the set of shared domains between bgcs of a pair, and return the number of
    anchor and non-anchor domains that were used in the calculation.

    Args:
        bgc_pair (BGCPair): A bgc pair to calculate the shared domain distance for
        anchor_domains (set[str]): a set of domains to use as anchor domains

    Returns:
        tuple[float, float, int, int]: distance for anchor domains, distance for non-anchor domains,
        number of shared ancor domains, number of shared non-anchor domains
    """
    domain_set_a, domain_set_b = bgc_pair.comparable_region.get_domain_sets()
    a_domain_list, b_domain_list = bgc_pair.comparable_region.get_domain_lists()
    a_domain_dict, b_domain_dict = bgc_pair.comparable_region.get_domain_dicts()

    intersect = domain_set_a & domain_set_b

    distance_anchor = 0.0
    distance_non_nachor = 0.0

    domains_anchor = 0
    domains_non_anchor = 0

    for shared_domain in sorted([hsp.domain for hsp in intersect]):
        sum_seq_dist, normalization_element = get_sum_seq_dist(
            a_domain_list, b_domain_list, a_domain_dict, b_domain_dict, shared_domain
        )

        if shared_domain[:7] in anchor_domains:
            distance_anchor += sum_seq_dist
            domains_anchor += normalization_element
        else:
            distance_non_nachor += sum_seq_dist
            domains_non_anchor += normalization_element

    return distance_anchor, distance_non_nachor, domains_anchor, domains_non_anchor


def calc_dss_pair_legacy(
    bgc_pair: RecordPair, anchor_domains: Optional[set[str]] = None, anchor_boost=1.0
) -> float:  # pragma no cover
    """Calculate the DSS for a given pair based on how the BiG-SCAPE 1.0 implementation works

    Args:
        bgc_pair (BGCPair): Pair of BGCs to calculate dss for
        anchor_domains (Optional[set[str]], optional): A list of domains to consider anchor domains.
        These domains have more impact in the calculation of DSS. Defaults to None.
        anchor_boost (float, optional): A scaling factor for anchor domains. Defaults to 1.0.

    Returns:
        float: _description_
    """
    # intialize an empty set of anchor domains if it is set to None
    if anchor_domains is None:
        anchor_domains = set(LEGACY_ANCHOR_DOMAINS)

    # initialize the distances by getting the distances from all unshared domains, which
    # all add 1 to the difference
    distance_anchor, distance_non_anchor = get_distance_from_unshared(
        bgc_pair, anchor_domains
    )

    # since we know we added whole numbers in the above function, we can re-use the
    # results to get the number of domains that we used
    domains_anchor = int(distance_anchor)
    domains_non_anchor = int(distance_non_anchor)

    # now we have to do add the distances that we get from procesing the alignments
    # s_ means shared
    (
        s_dist_anchor,
        s_dist_non_anchor,
        s_domains_anchor,
        s_domains_non_anchor,
    ) = get_distance_from_shared(bgc_pair, anchor_domains)

    distance_anchor += s_dist_anchor
    distance_non_anchor += s_dist_non_anchor

    domains_anchor += s_domains_anchor
    domains_non_anchor += s_domains_non_anchor

    # finally calculate the score
    # first case: no anchor domains
    if domains_anchor == 0:
        return 1 - distance_non_anchor / domains_non_anchor

    # second case: no non-anchor domains
    if domains_non_anchor == 0:
        return 1 - distance_anchor / domains_anchor

    # third case: mix of both
    dss_anchor = distance_anchor / domains_anchor
    dss_non_anchor = distance_non_anchor / domains_non_anchor

    # Calculate proper, proportional weight to each kind of domain
    total_domains = domains_anchor + domains_non_anchor
    anchor_percent = domains_anchor / total_domains * anchor_boost
    non_anchor_percent = domains_non_anchor / total_domains

    # boost anchor subcomponent and re-normalize
    total_percent = anchor_percent + non_anchor_percent
    anchor_weight = anchor_percent / total_percent
    non_anchor_weight = non_anchor_percent / total_percent

    # Use anchorboost parameter to boost percieved rDSS_anchor
    dss = (non_anchor_weight * dss_non_anchor) + (anchor_weight * dss_anchor)

    return 1 - dss
