"""Contains classes and functions for generating bins of Regions to compare

At this level, the comparisons are referred to as pairs. Whenever anything talks about
pairs, it refers to things generated from these classes. This is distinct from what are
referred to as edges, which are pairs that have a (set of) distances between them and
may be present in the database.
"""

# from python
from __future__ import annotations
from itertools import combinations
from typing import Generator
from sqlalchemy import select, func

# from other modules
from src.data import DB
from src.genbank import BGCRecord
from src.enums import SOURCE_TYPE

# from this module
from .comparable_region import ComparableRegion


class RecordPairGenerator:
    """Generator to generate all-vs-all comparisons form a list of BGC records

    Attributes:
        label (str): Label for this bin
        source_records (list[BGCRecord]): List of BGC records to generate pairs from
    """

    def __init__(self, label: str):
        self.label = label
        self.source_records: list[BGCRecord] = []
        self.record_ids: set[int] = set()

    def generate_pairs(self, legacy_sorting=False) -> Generator[RecordPair, None, None]:
        """Returns a generator for all vs all Region pairs in this bins

        This will always generate all pairs, and does not take into account any edges
        that already exist in the database

        Args:
            legacy_sorting (bool, optional): Whether to sort the BGC records by GBK file name.
            This is done in BiG-SCAPE 1.0 and can affect scoring depending on which of
            the BGC regions is region A in a pair. TODO: may be removed in the future

        Yields:
            Generator[RegionPair]: Generator for Region pairs in this bin
        """
        for record_a, record_b in combinations(self.source_records, 2):
            if legacy_sorting:
                sorted_a, sorted_b = sorted((record_a, record_b), key=sort_name_key)
                pair = RecordPair(sorted_a, sorted_b)

            else:
                pair = RecordPair(record_a, record_b)

            yield pair

    def generate_batch(
        self, batch_size: int, legacy_sorting=False
    ) -> Generator[list[RecordPair], None, None]:
        """Generator for batches of pairs in this bin

        Args:
            batch_size (int): The size of the batch to generate
            legacy_sorting (bool, optional): Whether to sort the BGC records by GBK file name.
            This is done in BiG-SCAPE 1.0 and can affect scoring depending on which of
            the BGC records is region A in a pair.

        Yields:
            Generator[list[RegionPair], None, None]]: Generator for Region pairs in this
            bin
        """
        batch = []
        while pair := next(self.generate_pairs(legacy_sorting), None):
            batch.append(pair)
            if len(batch) == batch_size:
                yield batch
                batch = []

    def num_pairs(self) -> int:
        """Return the number of pairs expected to be generated by the pairs Generator

        Returns:
            int: The number of pairs expected to be generated from the Generator
        """

        if len(self.source_records) < 2:
            return 0

        len_all_records = len(self.source_records)

        # (n*(n-1)) / 2
        num_all_pairs = int((len_all_records * (len_all_records - 1)) / 2)

        return num_all_pairs

    def add_records(self, record_list: list[BGCRecord]):
        """Adds BGC records to this bin and creates a generator for the pairs

        Args:
            record_list (list[BGCRecord]): List of BGC records to add to this bin
        """
        self.source_records.extend(record_list)
        self.record_ids.update([region._db_id or -1 for region in record_list])

        # throw a ValueError if any region db id is None, as we expect all regions to be
        # represented in the database
        if None in self.record_ids:
            raise ValueError("Region in bin has no db id!")

    def __repr__(self) -> str:
        return (
            f"Bin '{self.label}': {self.num_pairs()} pairs from "
            f"{len(self.source_records)} BGC records"
        )


class RecordPairGeneratorQueryRef(RecordPairGenerator):
    """Describes a bin of BGC records to generate pairs from. Pair generation excludes ref <-> ref pairs"""

    def generate_pairs(self, legacy_sorting=False) -> Generator[RecordPair, None, None]:
        """Returns an Generator for Region pairs in this bin, all pairs are generated
        except for ref <-> ref pairs

        Args:
            legacy_sorting (bool, optional): Whether to sort the BGC records by GBK file name.
            This is done in BiG-SCAPE 1.0 and can affect scoring depending on which of
            the BGC records is region A in a pair.

        Yields:
            Generator[RegionPair]: Generator for Region pairs in this bin
        """
        for bgc_a, bgc_b in combinations(self.source_records, 2):
            if legacy_sorting:
                sorted_a, sorted_b = sorted((bgc_a, bgc_b), key=sort_name_key)
                pair = RecordPair(sorted_a, sorted_b)

            else:
                if bgc_a.parent_gbk is not None:
                    bgc_a_not_query = bgc_a.parent_gbk.source_type != SOURCE_TYPE.QUERY
                if bgc_b.parent_gbk is not None:
                    bgc_b_not_query = bgc_b.parent_gbk.source_type != SOURCE_TYPE.QUERY
                if bgc_a_not_query and bgc_b_not_query:
                    continue

                pair = RecordPair(bgc_a, bgc_b)

            yield pair

    def num_pairs(self) -> int:
        """Returns the number of pairs expected to be generated by the pairs Generator,
        which excludes ref <-> ref pairs

        Returns:
            int: The number of pairs expected to be generated from the Generator
        """

        if len(self.source_records) < 2:
            return 0

        len_ref = 0
        for record in self.source_records:
            if (
                record.parent_gbk is not None
                and record.parent_gbk.source_type != SOURCE_TYPE.QUERY
            ):
                len_ref += 1

        len_all_records = len(self.source_records)

        # (n*(n-1)) / 2
        num_all_pairs = int((len_all_records * (len_all_records - 1)) / 2)
        num_ref_pairs = int((len_ref * (len_ref - 1)) / 2)

        return num_all_pairs - num_ref_pairs


class RecordPairGeneratorConRefSinRef(RecordPairGenerator):
    """Describes a bin of BGC records to generate pairs from, pair generation is limited to connected-ref
    to singleton ref nodes

    Args:
        label (str): Label for this bin
        source_records (list[BGCRecord]): List of BGC records to generate pairs from
    """

    def __init__(self, label: str):
        super().__init__(label)

        self.ref_nodes = self.network.get_nodes(
            node_types=[SOURCE_TYPE.REFERENCE, SOURCE_TYPE.MIBIG]
        )
        self.ref_singletons = self.network.get_singletons(
            node_types=[SOURCE_TYPE.REFERENCE, SOURCE_TYPE.MIBIG]
        )
        self.ref_connected_nodes = [
            node for node in self.ref_nodes if node not in self.ref_singletons
        ]

    def recalculate_nodes(self):
        """Recalculate new connected nodes and new singleton nodes for this bin, so that
        pair generation is only performed on new connected vs new singleton nodes
        """

        new_ref_singletons = self.network.get_singletons(
            node_types=[SOURCE_TYPE.REFERENCE, SOURCE_TYPE.MIBIG]
        )
        new_ref_connected_nodes = [
            node for node in self.ref_singletons if node not in new_ref_singletons
        ]

        self.ref_connected_nodes = new_ref_connected_nodes
        self.ref_singletons = new_ref_singletons

    def generate_pairs(self, legacy_sorting=False) -> Generator[RecordPair, None, None]:
        """Returns an Generator for Region pairs in this bin, pairs are only generated between
        given nodes to all singleton ref nodes

        Args:
            network (BSNetwork): A network object to use for finding and sorting the nodes.
            all records in this bin must be in the network as nodes, with or without edges

            given_nodes (list[BGCRecord]): List of BGC records to generate pairs from

        Yields:
            Generator[RegionPair]: Generator for Region pairs in this bin
        """

        if len(self.ref_connected_nodes) == 0 or len(self.ref_singletons) == 0:
            return 0

        for bgc_a in self.ref_connected_nodes:
            for bgc_b in self.ref_singletons:
                if legacy_sorting:
                    sorted_a, sorted_b = sorted((bgc_a, bgc_b), key=sort_name_key)
                    pair = RecordPair(sorted_a, sorted_b)

                else:
                    pair = RecordPair(bgc_a, bgc_b)

                if pair not in self.network:
                    yield pair

    def num_pairs(self) -> int:
        """Returns the number of pairs expected to be generated by the pairs Generator,
        which includes only given node <-> singleton ref pairs

        Returns:
            int: The number of pairs expected to be generated from the Generator
        """

        num_rec_connected_nodes = len(self.ref_connected_nodes)
        num_ref_singletons = len(self.ref_singletons)

        num_pairs = num_rec_connected_nodes * num_ref_singletons

        return num_pairs


class PartialRecordPairGenerator(RecordPairGenerator):
    """Generator that wraps around another RecordPairGenerator to exclude any distances
    already in the database
    """

    def __init__(self, bin):
        super().__init__(bin.label)
        self.bin = bin

    def num_pairs(self) -> int:
        distance_table = DB.metadata.tables["distance"]

        # get all region._db_id in the bin where the region_a_id and region_b_id are in the
        # bin
        select_statement = (
            select(func.count(distance_table.c.region_a_id))
            .where(distance_table.c.region_a_id.in_(self.bin.record_ids))
            .where(distance_table.c.region_b_id.in_(self.bin.record_ids))
        )

        # get count
        existing_distance_count = DB.execute(select_statement).scalar_one()

        # subtract from expected number of distances
        return self.bin.num_pairs() - existing_distance_count

    def generate_pairs(self, legacy_sorting=False) -> Generator[RecordPair, None, None]:
        distance_table = DB.metadata.tables["distance"]

        # get all region._db_id in the bin
        select_statement = (
            select(distance_table.c.region_a_id, distance_table.c.region_b_id)
            .where(distance_table.c.region_a_id.in_(self.bin.record_ids))
            .where(distance_table.c.region_b_id.in_(self.bin.record_ids))
        )

        # generate a set of tuples of region id pairs
        existing_distances = set(DB.execute(select_statement).fetchall())

        for pair in self.bin.generate_pairs(legacy_sorting):
            # if the pair is not in the set of existing distances, yield it
            if (pair.region_a._db_id, pair.region_b._db_id) not in existing_distances:
                yield pair

    def add_records(self, _: list[BGCRecord]):
        raise NotImplementedError("Cannot add records to a PartialRecordPairGenerator")


class RecordPair:
    """Contains a pair of BGC records, which can be any type of BGCRecord

    This will also contain any other necessary information specific to this pair needed
    to generate the scores
    """

    def __init__(self, region_a: BGCRecord, region_b: BGCRecord):
        self.region_a = region_a
        self.region_b = region_b

        if region_a.parent_gbk is None or region_b.parent_gbk is None:
            raise ValueError("Region in pair has no parent GBK!")

        # comparable regions start at the full ranges
        a_len = len(region_a.parent_gbk.genes)
        b_len = len(region_b.parent_gbk.genes)

        self.comparable_region: ComparableRegion = ComparableRegion(
            self, 0, a_len, 0, b_len, False
        )

    def __repr__(self) -> str:
        return f"Pair {self.region_a} - {self.region_b}"

    def __hash__(self) -> int:
        return hash((self.region_a, self.region_b))

    def __eq__(self, _o) -> bool:
        if not isinstance(_o, RecordPair):
            return False

        return self.region_a == _o.region_a and self.region_b == _o.region_b


def generate_mix(bgc_list: list[BGCRecord]) -> RecordPairGenerator:
    """Generate an all-vs-all bin of the supplied BGC records

    Args:
        bgc_list (list[BGCRecord]): BGC records to make into an all-vs-all bin

    Returns:
        BGCBin: The all-vs-all BGC bin
    """
    mix_bin = RecordPairGenerator("mix")

    mix_bin.add_records(bgc_list)

    return mix_bin


def sort_name_key(record: BGCRecord) -> str:
    """Return the parent gbk file name without extension, or None if no parent gbk is
    assigned

    Args:
        record (BGCRecord): A BGCrecord

    Returns:
        str: the parent gbk file name without extension
    """
    if record.parent_gbk is None:
        return ""

    return record.parent_gbk.path.name[:-4]
