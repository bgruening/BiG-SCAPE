"""Contains a description of a bgc pair to pass to distance calculation and networking
"""

# from python
from __future__ import annotations
from itertools import combinations
from typing import TYPE_CHECKING, Iterator, Optional

# from dependencies
# from other modules
from src.genbank import BGCRecord
from src.enums import SOURCE_TYPE

# from this module
from .comparable_region import ComparableRegion

# from circular imports
if TYPE_CHECKING:  # pragma no cover
    from src.network import BSNetwork


class RecordPairGenerator:
    """Describes a bin of BGCs to generate pairs from

    Attributes:
        label (str): Label for this bin
        source_records (list[BGCRecord]): List of BGCs to generate pairs from
    """

    def __init__(self, label: str):
        self.label = label
        self.source_records: list[BGCRecord] = []

    def generate_pairs(
        self, network: Optional[BSNetwork] = None, legacy_sorting=False
    ) -> Iterator[BGCPair]:
        """Returns an iterator for BGC pairs in this bin"""

        raise NotImplementedError

    def num_pairs(self) -> int:
        """Returns the number of pairs expected to be generated by the pairs iterator"""

        raise NotImplementedError

    def add_bgcs(self, bgc_list: list[BGCRecord]):
        """Adds BGCs to this bin and creates a generator for the pairs

        Args:
            bgc_list (list[BGCRecord]): List of BGCs to add to this bin
        """
        self.source_records.extend(bgc_list)

    def __repr__(self) -> str:
        return (
            f"Bin '{self.label}': {self.num_pairs()} pairs from "
            f"{len(self.source_records)} BGCs"
        )


class RecordPairGeneratorQueryRef(RecordPairGenerator):
    """Describes a bin of BGCs to generate pairs from. Pair generation excludes ref <-> ref pairs"""

    def generate_pairs(
        self, network: Optional[BSNetwork] = None, legacy_sorting=False
    ) -> Iterator[BGCPair]:
        """Returns an iterator for BGC pairs in this bin, all pairs are generated
        except for ref <-> ref pairs

        Args:
            network (BSNetwork, optional): A network object to use for filtering. If
            this is set, the generator will not yield any pairs that already have an
            edge in the network
            legacy_sorting (bool, optional): Whether to sort the BGCs by GBK file name.
            This is done in BiG-SCAPE 1.0 and can affect scoring depending on which of
            the BGCs is region A in a pair.

        Yields:
            Iterator[BGCPair]: Iterator for BGC pairs in this bin
        """
        for bgc_a, bgc_b in combinations(self.source_records, 2):
            if legacy_sorting:
                sorted_a, sorted_b = sorted((bgc_a, bgc_b), key=sort_name_key)
                pair = BGCPair(sorted_a, sorted_b)

            else:
                bgc_a_not_query = bgc_a.parent_gbk.source_type != SOURCE_TYPE.QUERY
                bgc_b_not_query = bgc_b.parent_gbk.source_type != SOURCE_TYPE.QUERY
                if bgc_a_not_query and bgc_b_not_query:
                    continue

                pair = BGCPair(bgc_a, bgc_b)

            if network is None or pair not in network:
                yield pair

    def num_pairs(self) -> int:
        """Returns the number of pairs expected to be generated by the pairs iterator,
        which excludes ref <-> ref pairs

        Returns:
            int: The number of pairs expected to be generated from the iterator
        """

        if len(self.source_records) < 2:
            return 0

        len_ref = 0
        for record in self.source_records:
            if record.parent_gbk.source_type != SOURCE_TYPE.QUERY:
                len_ref += 1

        len_all_records = len(self.source_records)

        # (n*(n-1)) / 2
        num_all_pairs = int((len_all_records * (len_all_records - 1)) / 2)
        num_ref_pairs = int((len_ref * (len_ref - 1)) / 2)

        return num_all_pairs - num_ref_pairs


class BGCPair:
    """Contains a pair of BGCs, which can be any type of BGCRecord

    This will also contain any other necessary information specific to this pair needed
    to generate the scores
    """

    def __init__(self, region_a: BGCRecord, region_b: BGCRecord):
        self.region_a = region_a
        self.region_b = region_b

        if region_a.parent_gbk is None or region_b.parent_gbk is None:
            raise ValueError("Region in pair has no parent GBK!")

        # comparable regions start at the full ranges
        a_len = len(region_a.parent_gbk.genes)
        b_len = len(region_b.parent_gbk.genes)

        self.comparable_region: ComparableRegion = ComparableRegion(
            self, 0, a_len, 0, b_len, False
        )

    def __repr__(self) -> str:
        return f"Pair {self.region_a} - {self.region_b}"


def generate_mix(bgc_list: list[BGCRecord]) -> RecordPairGeneratorQueryRef:
    """Generate an all-vs-all bin of the supplied BGCs

    Args:
        bgc_list (list[BGCRecord]): BGCs to make into an all-vs-all bin

    Returns:
        BGCBin: The all-vs-all BGC bin
    """
    mix_bin = RecordPairGeneratorQueryRef("mix")

    mix_bin.add_bgcs(bgc_list)

    return mix_bin


def sort_name_key(record: BGCRecord) -> str:
    """Return the parent gbk file name without extension, or None if no parent gbk is
    assigned

    Args:
        record (BGCRecord): A BGCrecord

    Returns:
        str: the parent gbk file name without extension
    """
    if record.parent_gbk is None:
        return ""

    return record.parent_gbk.path.name[:-4]
