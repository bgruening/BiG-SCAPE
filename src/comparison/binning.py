"""Contains a description of a bgc pair to pass to distance calculation and networking
"""

# from python
from __future__ import annotations
from itertools import combinations
from typing import Iterator

# from dependencies
# from other modules
from src.genbank import BGCRecord

# from this module
from .comparable_region import ComparableRegion


class BGCBin:
    """Contains a list of many-to-many BGC pairs and methods to manipulate the bin"""

    def __init__(self, label: str):
        self.label = label
        self.source_records: list[BGCRecord] = []

    def pairs(self, legacy_sorting=False) -> Iterator[BGCPair]:
        """Returns an iterator for BGC pairs in this bin

        Args:
            legacy_sorting (bool, optional): Whether to sort the

        Yields:
            Iterator[BGCPair]: Iterator for BGC pairs in this bin
        """
        for bgc_a, bgc_b in combinations(self.source_records, 2):
            if legacy_sorting:
                sorted_a, sorted_b = sorted(
                    (bgc_a, bgc_b), key=lambda bgc: bgc.parent_gbk.path.name[:-4]
                )
                yield BGCPair(sorted_a, sorted_b)
                continue
            yield BGCPair(bgc_a, bgc_b)

    def add_bgcs(self, bgc_list: list[BGCRecord]):
        """Adds BGCs to this bin and creates a generator for the pairs

        Args:
            bgc_list (list[BGCRecord]): List of BGCs to add to this bin
        """
        self.source_records.extend(bgc_list)

    def num_pairs(self) -> int:
        """Returns the number of pairs expected to be generated by the pairs iterator

        Returns:
            int: The number of pairs expected to be generated from the iterator
        """
        if len(self.source_records) < 2:
            return 0
        # (n*(n-1)) / 2
        n = len(self.source_records)
        return int((n * (n - 1)) / 2)

    def __repr__(self) -> str:
        return (
            f"Bin '{self.label}': {self.num_pairs()} pairs from "
            f"{len(self.source_records)} BGCs"
        )


class BGCPair:
    """Contains a pair of BGCs, which can be any type of BGCRecord

    This will also contain any other necessary information specific to this pair needed
    to generate the scores
    """

    def __init__(self, region_a: BGCRecord, region_b: BGCRecord):
        self.region_a = region_a
        self.region_b = region_b

        if region_a.parent_gbk is None or region_b.parent_gbk is None:
            raise ValueError("Region in pair has no parent GBK!")

        # comparable regions start at the full ranges
        a_len = len(region_a.parent_gbk.genes)
        b_len = len(region_b.parent_gbk.genes)

        self.comparable_region: ComparableRegion = ComparableRegion(
            self, 0, a_len, 0, b_len, False
        )

    def find_lcs(self) -> tuple[int]:
        """Generate the comparable region for this BGC pair

        Returns:
            tuple[int]: A tuple in the form (a_start, a_stop, b_start, b_stop)
        """
        return self.comparable_region.find_lcs()

    def __repr__(self) -> str:
        return f"Pair {self.region_a} - {self.region_b}"


def generate_mix(bgc_list: list[BGCRecord]) -> BGCBin:
    """Generate an all-vs-all bin of the supplied BGCs

    Args:
        bgc_list (list[BGCRecord]): BGCs to make into an all-vs-all bin

    Returns:
        BGCBin: The all-vs-all BGC bin
    """
    mix_bin = BGCBin("mix")

    mix_bin.add_bgcs(bgc_list)

    return mix_bin
