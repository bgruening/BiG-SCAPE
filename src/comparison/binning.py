"""Contains a description of a bgc pair to pass to distance calculation and networking
"""

# from python
from __future__ import annotations
from itertools import combinations
from typing import TYPE_CHECKING, Iterator, Optional, Any

# from dependencies
# from other modules
from src.genbank import BGCRecord
from src.enums import SOURCE_TYPE

# from this module
from .comparable_region import ComparableRegion

# from circular imports
if TYPE_CHECKING:  # pragma no cover
    from src.network import BSNetwork


class RecordPairGenerator:
    """Describes a bin of BGCs to generate all-to-all pairs from

    Attributes:
        label (str): Label for this bin
        source_records (list[BGCRecord]): List of BGCs to generate pairs from
    """

    def __init__(self, label: str):
        self.label = label
        self.source_records: list[BGCRecord] = []

    def generate_pairs(
        self, network: Optional[BSNetwork] = None, legacy_sorting=False
    ) -> Iterator[BGCPair]:
        """Returns an iterator for all vs all BGC pairs in this bins

        Args:
            network (BSNetwork, optional): A network object to use for filtering. If
            this is set, the generator will not yield any pairs that already have an
            edge in the network
            legacy_sorting (bool, optional): Whether to sort the BGCs by GBK file name.
            This is done in BiG-SCAPE 1.0 and can affect scoring depending on which of
            the BGCs is region A in a pair.

        Yields:
            Iterator[BGCPair]: Iterator for BGC pairs in this bin
        """
        for bgc_a, bgc_b in combinations(self.source_records, 2):
            if legacy_sorting:
                sorted_a, sorted_b = sorted((bgc_a, bgc_b), key=sort_name_key)
                pair = BGCPair(sorted_a, sorted_b)

            else:
                pair = BGCPair(bgc_a, bgc_b)

            if network is None or pair not in network:
                yield pair

    def num_pairs(self) -> int:
        """Returns the number of pairs expected to be generated by the pairs iterator

        Returns:
            int: The number of pairs expected to be generated from the iterator
        """

        if len(self.source_records) < 2:
            return 0

        len_all_records = len(self.source_records)

        # (n*(n-1)) / 2
        num_all_pairs = int((len_all_records * (len_all_records - 1)) / 2)

        return num_all_pairs

    def add_bgcs(self, bgc_list: list[BGCRecord]):
        """Adds BGCs to this bin and creates a generator for the pairs

        Args:
            bgc_list (list[BGCRecord]): List of BGCs to add to this bin
        """
        self.source_records.extend(bgc_list)

    def __repr__(self) -> str:
        return (
            f"Bin '{self.label}': {self.num_pairs()} pairs from "
            f"{len(self.source_records)} BGCs"
        )


class RecordPairGeneratorQueryRef(RecordPairGenerator):
    """Describes a bin of BGCs to generate pairs from. Pair generation excludes ref <-> ref pairs"""

    def generate_pairs(
        self, network: Optional[BSNetwork] = None, legacy_sorting=False
    ) -> Iterator[BGCPair]:
        """Returns an iterator for BGC pairs in this bin, all pairs are generated
        except for ref <-> ref pairs

        Args:
            network (BSNetwork, optional): A network object to use for filtering. If
            this is set, the generator will not yield any pairs that already have an
            edge in the network
            legacy_sorting (bool, optional): Whether to sort the BGCs by GBK file name.
            This is done in BiG-SCAPE 1.0 and can affect scoring depending on which of
            the BGCs is region A in a pair.

        Yields:
            Iterator[BGCPair]: Iterator for BGC pairs in this bin
        """
        for bgc_a, bgc_b in combinations(self.source_records, 2):
            if legacy_sorting:
                sorted_a, sorted_b = sorted((bgc_a, bgc_b), key=sort_name_key)
                pair = BGCPair(sorted_a, sorted_b)

            else:
                if bgc_a.parent_gbk is not None:
                    bgc_a_not_query = bgc_a.parent_gbk.source_type != SOURCE_TYPE.QUERY
                if bgc_b.parent_gbk is not None:
                    bgc_b_not_query = bgc_b.parent_gbk.source_type != SOURCE_TYPE.QUERY
                if bgc_a_not_query and bgc_b_not_query:
                    continue

                pair = BGCPair(bgc_a, bgc_b)

            if network is None or pair not in network:
                yield pair

    def num_pairs(self) -> int:
        """Returns the number of pairs expected to be generated by the pairs iterator,
        which excludes ref <-> ref pairs

        Returns:
            int: The number of pairs expected to be generated from the iterator
        """

        if len(self.source_records) < 2:
            return 0

        len_ref = 0
        for record in self.source_records:
            if (
                record.parent_gbk is not None
                and record.parent_gbk.source_type != SOURCE_TYPE.QUERY
            ):
                len_ref += 1

        len_all_records = len(self.source_records)

        # (n*(n-1)) / 2
        num_all_pairs = int((len_all_records * (len_all_records - 1)) / 2)
        num_ref_pairs = int((len_ref * (len_ref - 1)) / 2)

        return num_all_pairs - num_ref_pairs


class RecordPairGeneratorConRefSinRef(RecordPairGenerator):
    """Describes a bin of BGCs to generate pairs from, pair generation is limited to connected-ref
    to singleton ref nodes"""

    def __init__(self, label: str, network: BSNetwork):
        super().__init__(label)
        self.network: BSNetwork = network
    # TODO: added *args: Any after mypy error 'signature incompatible with supertype'
    # check whether necessary, or better implementation

    def generate_pairs(self, *args: Any, legacy_sorting=False) -> Iterator[BGCPair]:
        """Returns an iterator for BGC pairs in this bin, pairs are only generated between
        each connected-ref (ref nodes that already have at least an edge) and all singleton ref nodes

        Args:
            network (BSNetwork): A network object to use for finding and sorting the nodes.
            all records in this bin must be in the network as nodes, with or without edges

        Yields:
            Iterator[BGCPair]: Iterator for BGC pairs in this bin
        """

        ref_nodes = self.network.get_nodes(
            node_types=[SOURCE_TYPE.REFERENCE, SOURCE_TYPE.MIBIG]
        )
        ref_singletons = self.network.get_singletons(
            node_types=[SOURCE_TYPE.REFERENCE, SOURCE_TYPE.MIBIG]
        )
        ref_connected_nodes = [node for node in ref_nodes if node not in ref_singletons]

        # TODO: make sure node type is still the original record, and make sure its in bin

        for bgc_a in ref_connected_nodes:
            for bgc_b in ref_singletons:
                if legacy_sorting:
                    sorted_a, sorted_b = sorted((bgc_a, bgc_b), key=sort_name_key)
                    pair = BGCPair(sorted_a, sorted_b)

                else:
                    pair = BGCPair(bgc_a, bgc_b)

                if (
                    bgc_a in self.source_records
                    and bgc_b in self.source_records
                    and pair not in self.network
                ):
                    yield pair

    def num_pairs(self) -> int:
        """Returns the number of pairs expected to be generated by the pairs iterator,
        which includes only conected ref <-> singleton ref pairs

        Returns:
            int: The number of pairs expected to be generated from the iterator
        """

        ref_nodes = self.network.get_nodes(
            node_types=[SOURCE_TYPE.REFERENCE, SOURCE_TYPE.MIBIG]
        )
        num_ref_nodes = len(ref_nodes)
        num_ref_singletons = len(
            self.network.get_singletons(
                node_types=[SOURCE_TYPE.REFERENCE, SOURCE_TYPE.MIBIG]
            )
        )
        num_connected_ref_nodes = num_ref_nodes - num_ref_singletons

        num_pairs = num_connected_ref_nodes * num_ref_singletons

        return num_pairs


class BGCPair:
    """Contains a pair of BGCs, which can be any type of BGCRecord

    This will also contain any other necessary information specific to this pair needed
    to generate the scores
    """

    def __init__(self, region_a: BGCRecord, region_b: BGCRecord):
        self.region_a = region_a
        self.region_b = region_b

        if region_a.parent_gbk is None or region_b.parent_gbk is None:
            raise ValueError("Region in pair has no parent GBK!")

        # comparable regions start at the full ranges
        a_len = len(region_a.parent_gbk.genes)
        b_len = len(region_b.parent_gbk.genes)

        self.comparable_region: ComparableRegion = ComparableRegion(
            self, 0, a_len, 0, b_len, False
        )

    def __repr__(self) -> str:
        return f"Pair {self.region_a} - {self.region_b}"


def generate_mix(bgc_list: list[BGCRecord]) -> RecordPairGenerator:
    """Generate an all-vs-all bin of the supplied BGCs

    Args:
        bgc_list (list[BGCRecord]): BGCs to make into an all-vs-all bin

    Returns:
        BGCBin: The all-vs-all BGC bin
    """
    mix_bin = RecordPairGenerator("mix")

    mix_bin.add_bgcs(bgc_list)

    return mix_bin


def sort_name_key(record: BGCRecord) -> str:
    """Return the parent gbk file name without extension, or None if no parent gbk is
    assigned

    Args:
        record (BGCRecord): A BGCrecord

    Returns:
        str: the parent gbk file name without extension
    """
    if record.parent_gbk is None:
        return ""

    return record.parent_gbk.path.name[:-4]
